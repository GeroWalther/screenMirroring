/**
 * Simple WebView Screen Receiver
 * Loads the working stream URL in a WebView
 */

import React, { useState, useEffect, useRef } from 'react';
import { View, StyleSheet, StatusBar, Text, Pressable, Dimensions, Alert } from 'react-native';
import { WebView } from 'react-native-webview';

// Get the stream URL - auto-detect local IP or use hardcoded
const getStreamURL = () => {
  const LOCAL_IP = '192.168.0.26'; // Your Mac's IP address
  const STREAM_PORT = 8082; // Your working stream port
  const DEFAULT_ROOM = 'living-room'; // Default room code
  
  return `http://${LOCAL_IP}:${STREAM_PORT}/web-receiver.html?room=${DEFAULT_ROOM}`;
};

export default function ScreenReceiver() {
  const [streamURL, setStreamURL] = useState(getStreamURL());
  const [showControls, setShowControls] = useState(true);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastRefresh, setLastRefresh] = useState(Date.now());
  const webViewRef = useRef<WebView | null>(null);
  const controlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const { width, height } = Dimensions.get('window');


  // Auto-hide controls after 5 seconds of no interaction
  const resetControlsTimeout = () => {
    if (controlsTimeoutRef.current) {
      clearTimeout(controlsTimeoutRef.current);
    }
    setShowControls(true);
    controlsTimeoutRef.current = setTimeout(() => {
      if (connectionState.isStreaming) {
        setShowControls(false);
      }
    }, 5000);
  };

  // Handle signaling messages
  const handleSignal = async (data: any) => {
    console.log('üì® Received signaling data:', data.type || 'unknown');
    
    if (!peerConnectionRef.current) {
      console.warn('‚ö†Ô∏è No peer connection available');
      return;
    }

    try {
      if (data.sdp) {
        if (data.sdp.type === 'offer') {
          console.log('üìù Processing SDP offer');
          setConnectionState(prev => ({ 
            ...prev, 
            status: 'webrtc-connecting', 
            message: 'Establishing connection...' 
          }));

          try {
            console.log('üîß Setting remote description...');
            await peerConnectionRef.current.setRemoteDescription(
              new RTCSessionDescription(data.sdp)
            );
            console.log('‚úÖ Remote description set successfully');

            console.log('üîß Creating answer...');
            const answer = await peerConnectionRef.current.createAnswer();
            console.log('‚úÖ Answer created:', answer.type);

            // Send answer immediately after creation, before setLocalDescription
            const answerMessage = {
              sdp: answer // Use the answer directly, not localDescription
            };
            console.log('üì§ Sending answer via signaling (before setLocal):', answerMessage.sdp?.type);
            
            if (signalingClientRef.current && signalingClientRef.current.sendSignal) {
              signalingClientRef.current.sendSignal(answerMessage);
              console.log('‚úÖ Answer sent successfully');
            } else {
              console.error('‚ùå Signaling client not available for sending answer');
            }

            // Skip setLocalDescription - it causes crashes in React Native WebRTC
            // The answer was already sent, which is sufficient for the connection
            console.log('‚úÖ Skipping setLocalDescription to prevent crash - answer already sent');
            
            // Mark connection as ready since we sent the answer
            setConnectionState(prev => ({ 
              ...prev, 
              status: 'webrtc-connecting', 
              message: 'Answer sent, waiting for connection...' 
            }));
            
          } catch (sdpError) {
            console.error('‚ùå SDP processing error:', sdpError);
            console.error('‚ùå SDP error details:', {
              message: sdpError.message,
              name: sdpError.name,
              stack: sdpError.stack
            });
            throw sdpError;
          }
        }
      } else if (data.ice) {
        console.log('üßÜ Adding ICE candidate:', data.ice.candidate?.substring(0, 50) + '...');
        try {
          await peerConnectionRef.current.addIceCandidate(
            new RTCIceCandidate(data.ice)
          );
          console.log('‚úÖ ICE candidate added successfully');
        } catch (iceError) {
          console.error('‚ùå ICE candidate error:', iceError);
          // Don't throw - ICE errors are often non-fatal
        }
      }
    } catch (error) {
      console.error('‚ùå Error handling signaling data:', error);
      console.error('‚ùå Error details:', {
        message: error.message,
        name: error.name,
        stack: error.stack
      });
      setConnectionState(prev => ({ 
        ...prev, 
        status: 'error', 
        message: `Connection failed: ${error.message}` 
      }));
    }
  };

  // Handle connection status changes
  const handleStatusChange = (status: string, data?: any) => {
    console.log('üìä Status change:', status, data);
    
    switch (status) {
      case 'connected':
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'connected', 
          message: 'Connected to signaling server',
          reconnectAttempt: 0
        }));
        break;
      case 'reconnecting':
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'reconnecting', 
          message: `Reconnecting... (attempt ${data.attempt})`,
          reconnectAttempt: data.attempt
        }));
        break;
      case 'disconnected':
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'disconnected', 
          message: 'Disconnected from server',
          isStreaming: false
        }));
        setRemoteStream(null);
        break;
      case 'error':
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'error', 
          message: 'Connection error occurred'
        }));
        break;
    }
  };

  // Initialize WebRTC peer connection
  const initializePeerConnection = () => {
    console.log('üîß Initializing peer connection');
    
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    // Handle remote stream (legacy onaddstream)
    pc.onaddstream = (event: any) => {
      console.log('üì∫ Remote stream added (legacy):', event.stream.id);
      setRemoteStream(event.stream);
      setConnectionState(prev => ({ 
        ...prev, 
        status: 'streaming', 
        message: 'Receiving screen share',
        isStreaming: true
      }));
      resetControlsTimeout();
    };
    
    // Handle remote stream (modern ontrack)
    pc.ontrack = (event: any) => {
      console.log('üì∫ Remote track added:', event.track.kind, event.streams?.length);
      console.log('üì∫ Track details:', {
        id: event.track.id,
        kind: event.track.kind,
        enabled: event.track.enabled,
        readyState: event.track.readyState,
        muted: event.track.muted
      });
      
      if (event.streams && event.streams.length > 0) {
        const remoteStream = event.streams[0];
        console.log('üì∫ Setting remote stream from ontrack:', remoteStream.id);
        console.log('üì∫ Stream tracks:', {
          videoTracks: remoteStream.getVideoTracks().length,
          audioTracks: remoteStream.getAudioTracks().length,
          active: remoteStream.active
        });
        
        setRemoteStream(remoteStream);
        
        // Comprehensive video track debugging
        const videoTracks = remoteStream.getVideoTracks();
        if (videoTracks.length > 0) {
          const track = videoTracks[0];
          console.log('üì∫ DETAILED VIDEO TRACK INFO:', {
            id: track.id,
            kind: track.kind,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState,
            label: track.label,
            // Additional track properties
            settings: track.getSettings ? track.getSettings() : 'getSettings not available',
            constraints: track.getConstraints ? track.getConstraints() : 'getConstraints not available',
            capabilities: track.getCapabilities ? track.getCapabilities() : 'getCapabilities not available'
          });
          
          // Try to get track stats if available
          if (track.getStats) {
            track.getStats().then(stats => {
              console.log('üì∫ VIDEO TRACK STATS:', stats);
            }).catch(err => {
              console.log('üì∫ Video track stats not available:', err.message);
            });
          }
          
          // Force enable the track if it's disabled
          if (!track.enabled) {
            console.log('‚ö†Ô∏è Video track is disabled, attempting to enable...');
            track.enabled = true;
          }
          
          // Check if track is muted and try to unmute
          if (track.muted) {
            console.log('üîá Video track is muted');
          }
          
          // Try to restart the track if it's not live
          if (track.readyState !== 'live') {
            console.log('‚ö†Ô∏è Video track is not live, state:', track.readyState);
          }
          
          // Additional debugging - check if we can clone the track
          try {
            const clonedTrack = track.clone();
            console.log('üîÑ Successfully cloned video track:', clonedTrack.id);
          } catch (cloneError) {
            console.log('‚ùå Cannot clone track:', cloneError.message);
          }
          
          // Android TV compatibility - minimal track handling
          console.log('üì∫ Android TV: Using basic track info only');
          console.log('üì∫ Track enabled:', track.enabled, '| Muted:', track.muted, '| State:', track.readyState);
          
          // Ensure track is enabled (this should work on Android TV)
          if (!track.enabled) {
            track.enabled = true;
            console.log('‚ö° Force-enabled video track');
          }
        }
        
        // Log stream URL details
        try {
          const streamUrl = remoteStream.toURL();
          console.log('üîó Stream URL details:', {
            url: streamUrl,
            urlType: typeof streamUrl,
            urlLength: streamUrl ? streamUrl.length : 0
          });
        } catch (urlError) {
          console.error('‚ùå Error getting stream URL:', urlError);
        }
        
        // FORCE streaming state immediately when remote stream detected
        console.log('üì¶ FORCING STREAMING STATE - Remote stream detected!');
        setConnectionState({
          status: 'streaming', 
          message: 'Screen Sharing Active - Stream Received!',
          isStreaming: true,
          reconnectAttempt: 0
        });
        
        // Force check the current peer connection state with more aggressive timing
        const checkConnection = () => {
          if (peerConnectionRef.current) {
            console.log('üîç DETAILED CONNECTION CHECK:');
            console.log('  - connectionState:', peerConnectionRef.current.connectionState);
            console.log('  - iceConnectionState:', peerConnectionRef.current.iceConnectionState);
            console.log('  - signalingState:', peerConnectionRef.current.signalingState);
            console.log('  - iceGatheringState:', peerConnectionRef.current.iceGatheringState);
            
            // More aggressive connection detection
            const isConnected = peerConnectionRef.current.connectionState === 'connected' ||
                              peerConnectionRef.current.iceConnectionState === 'connected' ||
                              peerConnectionRef.current.iceConnectionState === 'completed';
            
            const isConnecting = peerConnectionRef.current.connectionState === 'connecting' ||
                               peerConnectionRef.current.iceConnectionState === 'checking' ||
                               peerConnectionRef.current.iceConnectionState === 'connecting';
            
            if (isConnected) {
              console.log('‚úÖ CONNECTION ESTABLISHED! Forcing streaming state...');
              setConnectionState(prev => ({ 
                ...prev, 
                status: 'streaming', 
                message: 'Connected and streaming!',
                isStreaming: true
              }));
            } else if (isConnecting) {
              console.log('üîÑ Connection in progress...');
            } else {
              console.log('‚ö†Ô∏è Connection state unclear - forcing streaming anyway since we have remote stream');
              // If we have a remote stream but unclear connection, assume it's working
              setConnectionState(prev => ({ 
                ...prev, 
                status: 'streaming', 
                message: 'Stream received - attempting playback',
                isStreaming: true
              }));
            }
          }
        };
        
        // Check multiple times with different delays
        setTimeout(checkConnection, 500);
        setTimeout(checkConnection, 1500);
        setTimeout(checkConnection, 3000);
        resetControlsTimeout();
      } else {
        console.log('‚ö†Ô∏è No streams in ontrack event');
      }
    };

    // Handle connection state changes
    pc.onconnectionstatechange = () => {
      console.log('üîó RECEIVER WebRTC Connection state:', pc.connectionState);
      
      if (pc.connectionState === 'connected') {
        console.log('‚úÖ RECEIVER WebRTC Connected!');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'streaming', 
          message: 'WebRTC Connected - Receiving video',
          isStreaming: true
        }));
      } else if (pc.connectionState === 'connecting') {
        console.log('üîó RECEIVER WebRTC Connecting...');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'webrtc-connecting', 
          message: 'WebRTC connecting...',
          isStreaming: false
        }));
      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
        console.log('‚ùå RECEIVER WebRTC Disconnected/Failed');
        setRemoteStream(null);
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'disconnected', 
          message: 'WebRTC connection lost',
          isStreaming: false
        }));
      }
    };

    // Handle ICE candidates
    pc.onicecandidate = (event: any) => {
      if (event.candidate) {
        console.log('üßä Sending ICE candidate');
        signalingClientRef.current?.sendSignal({
          ice: event.candidate,
        });
      }
    };

    // Handle ICE connection state
    pc.oniceconnectionstatechange = () => {
      console.log('üßÜ RECEIVER ICE connection state:', pc.iceConnectionState);
      
      if (pc.iceConnectionState === 'connected') {
        console.log('‚úÖ RECEIVER ICE Connected!');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'streaming', 
          message: 'ICE Connected - Video should be flowing',
          isStreaming: true
        }));
      } else if (pc.iceConnectionState === 'completed') {
        console.log('‚úÖ RECEIVER ICE Completed!');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'streaming', 
          message: 'ICE Completed - Optimal connection established',
          isStreaming: true
        }));
      } else if (pc.iceConnectionState === 'checking') {
        console.log('üßÜ RECEIVER ICE Checking...');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'webrtc-connecting', 
          message: 'ICE checking connectivity...',
          isStreaming: false
        }));
      } else if (pc.iceConnectionState === 'failed') {
        console.log('‚ùå RECEIVER ICE Failed!');
        setConnectionState(prev => ({ 
          ...prev, 
          status: 'error', 
          message: 'ICE connection failed',
          isStreaming: false
        }));
      }
    };

    return pc;
  };

  // Connect to signaling server and initialize WebRTC
  const connect = async () => {
    console.log('üöÄ Starting connection process');
    
    try {
      // Initialize peer connection
      peerConnectionRef.current = initializePeerConnection();

      // Create signaling client
      signalingClientRef.current = createWebRTCSignaling(SIGNALING_URL, {
        role: 'answerer', // Must match sender's 'to' field
        room: room,
        onSignal: handleSignal,
        onStatusChange: handleStatusChange,
      });

      // Connect to signaling server
      setConnectionState(prev => ({ 
        ...prev, 
        status: 'connecting', 
        message: 'Connecting to signaling server...' 
      }));
      
      signalingClientRef.current.connect();

    } catch (error) {
      console.error('‚ùå Connection failed:', error);
      setConnectionState(prev => ({ 
        ...prev, 
        status: 'error', 
        message: 'Failed to initialize connection'
      }));
    }
  };

  // Disconnect and cleanup
  const disconnect = () => {
    console.log('üîå Disconnecting...');
    
    if (signalingClientRef.current) {
      signalingClientRef.current.close();
      signalingClientRef.current = null;
    }

    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }

    if (controlsTimeoutRef.current) {
      clearTimeout(controlsTimeoutRef.current);
      controlsTimeoutRef.current = null;
    }

    setRemoteStream(null);
    setConnectionState({
      status: 'disconnected',
      message: 'Disconnected',
      reconnectAttempt: 0,
      isStreaming: false,
    });
    setShowControls(true);
  };

  // Auto-connect on mount
  useEffect(() => {
    console.log('üì∫ Screen Mirror Receiver initializing...');
    connect();

    // Temporarily disable cleanup to prevent constant disconnections
    // return () => {
    //   disconnect();
    // };
  }, []); // Empty dependency array - run once on mount

  // TV interface - always show controls
  const handleScreenTap = () => {
    // No-op for TV interface
  };

  // Get status indicator color
  const getStatusColor = () => {
    switch (connectionState.status) {
      case 'connected': return '#4CAF50'; // Green
      case 'connecting': return '#FF9800'; // Orange
      case 'webrtc-connecting': return '#FF9800'; // Orange
      case 'streaming': return '#2196F3'; // Blue
      case 'reconnecting': return '#FF9800'; // Orange
      case 'error': return '#f44336'; // Red
      default: return '#757575'; // Gray
    }
  };

  // Debug current state
  console.log('üñºÔ∏è RENDER - Current state:', {
    hasRemoteStream: !!remoteStream,
    remoteStreamId: remoteStream?.id,
    remoteStreamActive: remoteStream?.active,
    remoteStreamURL: remoteStream?.toURL?.(),
    connectionStatus: connectionState.status,
    isStreaming: connectionState.isStreaming,
    message: connectionState.message,
    renderMode: renderMode
  });

  return (
    <Pressable style={styles.root} onPress={handleScreenTap}>
      <StatusBar hidden />

      {/* Video Stream - Simplified for Android TV */}
      {remoteStream ? (
        <>
          {/* Full screen attempt - streamURL */}
          <RTCView
            streamURL={remoteStream.toURL()}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              backgroundColor: 'black',
              zIndex: 0
            }}
            objectFit="contain"
            mirror={false}
          />
          {/* Android TV Optimized RTCView - Maximum Compatibility */}
          <RTCView
            streamURL={remoteStream.toURL()}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              backgroundColor: '#000000',
              zIndex: 1
            }}
            objectFit="contain"
          />
          
          {/* Test 1: RTCView with stream object instead of streamURL */}
          <RTCView
            stream={remoteStream}
            style={{
              position: 'absolute',
              top: 50,
              left: 50,
              width: 400,
              height: 300,
              backgroundColor: 'red',
              borderWidth: 5,
              borderColor: 'yellow',
              zIndex: 10
            }}
            objectFit="cover"
            mirror={false}
          />
          
          {/* Test 2: Different objectFit */}
          <RTCView
            streamURL={remoteStream.toURL()}
            style={{
              position: 'absolute',
              top: 400,
              left: 50,
              width: 400,
              height: 300,
              backgroundColor: 'blue',
              borderWidth: 5,
              borderColor: 'white',
              zIndex: 11
            }}
            objectFit="fill"
          />
          
          {/* Test 3: No objectFit at all */}
          <RTCView
            stream={remoteStream}
            style={{
              position: 'absolute',
              bottom: 50,
              right: 50,
              width: 300,
              height: 200,
              backgroundColor: 'green',
              borderWidth: 3,
              borderColor: 'cyan',
              zIndex: 12
            }}
          />
          
          {/* TV-friendly debug overlay with remote control support */}
          <View style={{position: 'absolute', top: 20, left: 20, backgroundColor: 'rgba(0,0,0,0.9)', padding: 15, borderRadius: 10, zIndex: 1000, maxWidth: 400}}>
            <Text style={{color: 'lime', fontSize: 18, fontWeight: 'bold', marginBottom: 8}}>
              üì∫ STREAM ACTIVE! Mode: {renderMode}
            </Text>
            <Text style={{color: 'white', fontSize: 14, marginBottom: 2}}>
              ID: {remoteStream.id.substring(0, 8)}...
            </Text>
            <Text style={{color: 'white', fontSize: 14, marginBottom: 2}}>
              Active: {remoteStream.active ? '‚úÖ YES' : '‚ùå NO'}
            </Text>
            <Text style={{color: 'white', fontSize: 14, marginBottom: 2}}>
              Tracks: {remoteStream.getVideoTracks().length} video
            </Text>
            <Text style={{color: 'white', fontSize: 14, marginBottom: 2}}>
              Track: {remoteStream.getVideoTracks()[0]?.readyState || 'N/A'} | {remoteStream.getVideoTracks()[0]?.enabled ? 'Enabled' : 'Disabled'}
            </Text>
            
            {/* TV-remote friendly button */}
            <Pressable 
              onPress={() => {
                const modes: ('streamURL' | 'stream' | 'both')[] = ['streamURL', 'stream', 'both'];
                const currentIndex = modes.indexOf(renderMode);
                const nextIndex = (currentIndex + 1) % modes.length;
                setRenderMode(modes[nextIndex]);
                console.log('üîÑ Switching render mode from', renderMode, 'to', modes[nextIndex]);
              }}
              hasTVPreferredFocus={true}
              style={{
                backgroundColor: '#00FF00',
                padding: 12,
                borderRadius: 8,
                marginTop: 10,
                alignItems: 'center',
                borderWidth: 2,
                borderColor: '#FFFFFF'
              }}
            >
              <Text style={{color: 'black', fontSize: 16, fontWeight: 'bold'}}>
                üîÑ Switch Mode: {renderMode}
              </Text>
            </Pressable>
          </View>
          
          {/* Android TV Status */}
          <View style={{position: 'absolute', bottom: 20, right: 20, backgroundColor: 'rgba(0,0,0,0.9)', padding: 12, borderRadius: 8, zIndex: 1000, maxWidth: 280}}>
            <Text style={{color: 'lime', fontSize: 16, fontWeight: 'bold', marginBottom: 8}}>üì∫ ANDROID TV MODE</Text>
            <Text style={{color: 'white', fontSize: 12, marginBottom: 4}}>Simplified RTCView:</Text>
            <View style={{flexDirection: 'column', gap: 3}}>
              <Text style={{color: 'white', backgroundColor: 'black', fontSize: 11, padding: 3, borderRadius: 2}}>üì∫ Full screen (black bg)</Text>
              <Text style={{color: 'yellow', backgroundColor: 'red', fontSize: 11, padding: 3, borderRadius: 2}}>üî¥ Test rectangle (red + yellow)</Text>
            </View>
            <Text style={{color: remoteStream?.getVideoTracks()?.[0]?.readyState === 'live' ? 'lime' : 'red', fontSize: 11, marginTop: 6, fontWeight: 'bold'}}>
              ‚óè Track: {remoteStream?.getVideoTracks()?.[0]?.readyState || 'N/A'}
            </Text>
            <Text style={{color: remoteStream?.getVideoTracks()?.[0]?.enabled ? 'lime' : 'red', fontSize: 11}}>
              ‚óè Enabled: {remoteStream?.getVideoTracks()?.[0]?.enabled ? 'YES' : 'NO'}
            </Text>
            <Text style={{color: 'cyan', fontSize: 10, marginTop: 4}}>VP8 codec (Android TV optimized)</Text>
          </View>
        </>
      ) : (
        /* Waiting State */
        <View style={styles.waitingContainer}>
          <Text style={styles.waitingText}>üì∫ Screen Mirror Receiver</Text>
          <Text style={styles.roomText}>Waiting for screen share...</Text>
          <View style={styles.roomCodeContainer}>
            <Text style={styles.roomCodeLabel}>Room Code:</Text>
            <Text style={styles.roomCode}>{room}</Text>
          </View>
          <Text style={styles.serverText}>Server: {SIGNALING_URL}</Text>
          <Text style={[styles.statusText, { color: getStatusColor() }]}>
            {connectionState.message}
          </Text>
        </View>
      )}

      {/* Status Overlay - Always visible for TV */}
      {(showControls || true) && (
        <View style={styles.overlay}>
          <View style={styles.statusContainer}>
            <View style={[styles.statusDot, { backgroundColor: getStatusColor() }]} />
            <Text style={styles.overlayStatusText}>{connectionState.message}</Text>
          </View>
          
          {/* Connection Info */}
          <View style={styles.infoContainer}>
            <Text style={styles.infoText}>Room: {room}</Text>
            <Text style={styles.infoText}>Status: {connectionState.status}</Text>
            {connectionState.reconnectAttempt > 0 && (
              <Text style={styles.infoText}>Retry: {connectionState.reconnectAttempt}</Text>
            )}
          </View>

          {/* TV Instructions */}
          <View style={styles.instructionsContainer}>
            <Text style={styles.instructionsText}>
              {remoteStream ? 'üì∫ Screen Sharing Active' : 'üì∫ Waiting for screen share...'}
            </Text>
          </View>
        </View>
      )}
    </Pressable>
  );
}

const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: '#000',
  },
  
  // Video Stream
  videoStream: {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    width: '100%',
    height: '100%',
    backgroundColor: '#000',
  },
  
  // Waiting State
  waitingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#000',
    padding: 20,
  },
  waitingText: {
    color: '#fff',
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 24,
  },
  roomText: {
    color: '#ccc',
    fontSize: 20,
    textAlign: 'center',
    marginBottom: 32,
  },
  roomCodeContainer: {
    backgroundColor: '#333',
    paddingHorizontal: 24,
    paddingVertical: 20,
    borderRadius: 12,
    marginBottom: 32,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#4CAF50',
  },
  roomCodeLabel: {
    color: '#ccc',
    fontSize: 16,
    marginBottom: 8,
  },
  roomCode: {
    color: '#4CAF50',
    fontSize: 32,
    fontWeight: 'bold',
    letterSpacing: 3,
  },
  serverText: {
    color: '#888',
    fontSize: 14,
    textAlign: 'center',
    marginBottom: 16,
    fontFamily: 'monospace',
  },
  statusText: {
    fontSize: 18,
    textAlign: 'center',
    fontWeight: '500',
  },
  
  // Overlay Controls
  overlay: {
    position: 'absolute',
    top: 50,
    left: 20,
    right: 20,
    zIndex: 10,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  statusDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 12,
  },
  overlayStatusText: {
    color: '#fff',
    fontSize: 16,
    flex: 1,
    fontWeight: '500',
  },
  
  // Connection Info
  infoContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.75)',
    padding: 12,
    borderRadius: 6,
    marginBottom: 12,
  },
  infoText: {
    color: '#ccc',
    fontSize: 14,
    marginBottom: 4,
    fontFamily: 'monospace',
  },
  
  // Instructions
  instructionsContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    padding: 10,
    borderRadius: 6,
    alignItems: 'center',
  },
  instructionsText: {
    color: '#fff',
    fontSize: 12,
    opacity: 0.8,
    textAlign: 'center',
  },
});
